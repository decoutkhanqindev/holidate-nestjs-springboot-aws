{
    "nodes": [
      {
        "parameters": {
          "mode": "insert",
          "pineconeIndex": {
            "__rl": true,
            "value": "holidate-training-ai-agent-n8n-index",
            "mode": "list",
            "cachedResultName": "holidate-training-ai-agent-n8n-index"
          },
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.vectorStorePinecone",
        "typeVersion": 1.3,
        "position": [
          640,
          0
        ],
        "id": "8aaa1cb5-7414-40c1-a6bc-cb7ed6cf22ea",
        "name": "Pinecone Vector Store",
        "credentials": {
          "pineconeApi": {
            "id": "MhJjsFjO00aj8Zen",
            "name": "PineconeApi account"
          }
        }
      },
      {
        "parameters": {
          "model": "text-embedding-3-large",
          "options": {
            "dimensions": 3072
          }
        },
        "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
        "typeVersion": 1.2,
        "position": [
          560,
          256
        ],
        "id": "46cc6385-cb35-48b1-85f6-eabc22f629e6",
        "name": "Embeddings OpenAI",
        "credentials": {
          "openAiApi": {
            "id": "DM5TLJVcvl7xyaex",
            "name": "OpenAi account"
          }
        }
      },
      {
        "parameters": {
          "url": "https://s3.ap-southeast-1.amazonaws.com/holidate-storage/?list-type=2&prefix=knowledge_base/vietnam/thu-do-ha-noi",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "aws",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -528,
          0
        ],
        "id": "441e3903-252d-4159-beb4-2de63808a244",
        "name": "Get KB data from S3",
        "credentials": {
          "aws": {
            "id": "HlsXaRvTuWFUrXHC",
            "name": "AWS (IAM) account"
          }
        }
      },
      {
        "parameters": {
          "dataPropertyName": "=data",
          "options": {}
        },
        "type": "n8n-nodes-base.xml",
        "typeVersion": 1,
        "position": [
          -288,
          0
        ],
        "id": "45563e43-d2a7-4c1b-9bd1-c2f302e648f9",
        "name": "Convert from XML to JSON"
      },
      {
        "parameters": {
          "fieldToSplitOut": "=ListBucketResult.Contents",
          "options": {}
        },
        "type": "n8n-nodes-base.splitOut",
        "typeVersion": 1,
        "position": [
          -64,
          0
        ],
        "id": "b13be1dc-dceb-4bcd-9201-c841d090ccc1",
        "name": "Split"
      },
      {
        "parameters": {
          "bucketName": "holidate-storage",
          "fileKey": "={{ $json.Key }}"
        },
        "type": "n8n-nodes-base.awsS3",
        "typeVersion": 2,
        "position": [
          160,
          0
        ],
        "id": "e0a76f9d-3452-4d81-9c90-cda835a063f2",
        "name": "Download files from S3",
        "credentials": {
          "aws": {
            "id": "HlsXaRvTuWFUrXHC",
            "name": "AWS (IAM) account"
          }
        }
      },
      {
        "parameters": {},
        "type": "n8n-nodes-base.manualTrigger",
        "typeVersion": 1,
        "position": [
          -768,
          0
        ],
        "id": "7af82656-3ba3-41e9-9e6a-c9a35d44441c",
        "name": "When clicking â€˜Execute workflowâ€™"
      },
      {
        "parameters": {
          "textSplittingMode": "custom",
          "options": {
            "metadata": {
              "metadataValues": [
                {
                  "name": "source",
                  "value": "={{ $json.metadata.source }}"
                },
                {
                  "name": "doc_id",
                  "value": "={{ $json.metadata.doc_id }}"
                },
                {
                  "name": "doc_type",
                  "value": "={{ $json.metadata.doc_type }}"
                },
                {
                  "name": "hotel_id",
                  "value": "={{ $json.metadata.hotel_id }}"
                },
                {
                  "name": "hotel_name",
                  "value": "={{ $json.metadata.hotel_name }}"
                },
                {
                  "name": "city_name",
                  "value": "={{ $json.metadata.city_name }}"
                },
                {
                  "name": "district_name",
                  "value": "={{ $json.metadata.district_name }}"
                },
                {
                  "name": "address",
                  "value": "={{ $json.metadata.address }}"
                },
                {
                  "name": "star_rating",
                  "value": "={{ $json.metadata.star_rating }}"
                },
                {
                  "name": "review_score",
                  "value": "={{ $json.metadata.review_score }}"
                },
                {
                  "name": "review_count",
                  "value": "={{ $json.metadata.review_count }}"
                },
                {
                  "name": "price",
                  "value": "={{ $json.metadata.price }}"
                },
                {
                  "name": "amenities",
                  "value": "={{ $json.metadata.amenities }}"
                },
                {
                  "name": "breakfast_included",
                  "value": "={{ $json.metadata.breakfast_included }}"
                },
                {
                  "name": "room_name",
                  "value": "={{ $json.metadata.room_name }}"
                },
                {
                  "name": "max_adults",
                  "value": "={{ $json.metadata.max_adults }}"
                },
                {
                  "name": "max_children",
                  "value": "={{ $json.metadata.max_children }}"
                },
                {
                  "name": "view_type",
                  "value": "={{ $json.metadata.view_type }}"
                },
                {
                  "name": "bed_type",
                  "value": "={{ $json.metadata.bed_type }}"
                },
                {
                  "name": "area_sqm",
                  "value": "={{ $json.metadata.area_sqm }}"
                },
                {
                  "name": "wifi_available",
                  "value": "={{ $json.metadata.wifi_available }}"
                },
                {
                  "name": "smoking_allowed",
                  "value": "={{ $json.metadata.smoking_allowed }}"
                },
                {
                  "name": "to_beach_meters",
                  "value": "={{ $json.metadata.to_beach_meters }}"
                },
                {
                  "name": "room_type",
                  "value": "={{ $json.metadata.room_type }}"
                },
                {
                  "name": "has_balcony",
                  "value": "={{ $json.metadata.has_balcony }}"
                }
              ]
            }
          }
        },
        "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
        "typeVersion": 1.1,
        "position": [
          768,
          272
        ],
        "id": "31376de0-7382-4a5c-862f-55e82a89dab6",
        "name": "Default Data Loader"
      },
      {
        "parameters": {
          "chunkOverlap": 100,
          "options": {
            "splitCode": "markdown"
          }
        },
        "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
        "typeVersion": 1,
        "position": [
          752,
          464
        ],
        "id": "f85e1a87-2147-4484-b458-848346df1d46",
        "name": "Recursive Character Text Splitter"
      },
      {
        "parameters": {
          "jsCode": "// N8N CODE NODE - Clean Markdown Optimized\n// Tá»‘i Æ°u pháº§n cleanedContent: loáº¡i bá» kÃ½ tá»± rÃ¡c, giá»¯ nguyÃªn ná»™i dung ngá»¯ nghÄ©a\n\nfor (const item of $input.all()) {\n  const binaryData = item.binary;\n  if (binaryData && binaryData.data) {\n    \n    // 1. Äá»ŒC FILE Gá»C\n    const rawContent = global.Buffer.from(binaryData.data.data, 'base64').toString('utf8');\n\n    // 2. TRÃCH XUáº¤T METADATA Tá»ª YAML FRONTMATTER (25 trÆ°á»ng cáº§n thiáº¿t)\n    const metadata = {};\n    metadata.source = binaryData.data.fileName || \"unknown\";\n    \n    // TrÃ­ch xuáº¥t YAML Frontmatter (giá»¯a 2 dáº¥u ---)\n    const yamlMatch = rawContent.match(/^---\\s*([\\s\\S]*?)\\s*---/);\n    const yamlContent = yamlMatch ? yamlMatch[1] : '';\n    \n    // Helper function Ä‘á»ƒ parse YAML value\n    const parseYamlValue = (pattern, defaultValue = null) => {\n      const match = yamlContent.match(pattern);\n      if (!match) return defaultValue;\n      const value = match[1].trim();\n      // Xá»­ lÃ½ boolean\n      if (value === 'true') return true;\n      if (value === 'false') return false;\n      // Xá»­ lÃ½ sá»‘\n      if (/^\\d+$/.test(value)) return parseInt(value, 10);\n      if (/^\\d+\\.\\d+$/.test(value)) return parseFloat(value);\n      // Xá»­ lÃ½ string (bá» dáº¥u ngoáº·c kÃ©p)\n      return value.replace(/^[\"']|[\"']$/g, '');\n    };\n    \n    const parseYamlArraySimple = (fieldName) => {\n      // TÃ¬m vá»‹ trÃ­ báº¯t Ä‘áº§u cá»§a field\n      const fieldPattern = new RegExp(`^${fieldName}:\\\\s*$`, 'm');\n      const fieldMatch = yamlContent.match(fieldPattern);\n      if (!fieldMatch) return [];\n      \n      const startIndex = fieldMatch.index + fieldMatch[0].length;\n      const remainingContent = yamlContent.substring(startIndex);\n      const lines = remainingContent.split('\\n');\n      const items = [];\n      \n      // Parse tá»«ng dÃ²ng cho Ä‘áº¿n khi gáº·p field má»›i hoáº·c section má»›i\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        \n        // Dá»«ng khi gáº·p section má»›i (# ===) hoáº·c field má»›i (chá»¯ cÃ¡i thÆ°á»ng + :)\n        if (line.startsWith('# ===') || /^[a-z_]+:\\s*$/.test(line)) {\n          break;\n        }\n        \n        // Bá» qua dÃ²ng trá»‘ng vÃ  comment Ä‘Æ¡n thuáº§n\n        if (!line || (line.startsWith('#') && !line.match(/^\\s*-\\s*\"/))) {\n          continue;\n        }\n        \n        // Match pattern: - \"value\" (cÃ³ thá»ƒ cÃ³ comment)\n        const itemMatch = line.match(/^\\s*-\\s*\"([^\"]+)\"/);\n        if (itemMatch) {\n          items.push(itemMatch[1]);\n        }\n      }\n      \n      return items;\n    };\n    \n    // === TRÃCH XUáº¤T 25 TRÆ¯á»œNG Cáº¦N THIáº¾T ===\n    \n    // === 1. IDENTITY ===\n    // 1. source (Ä‘Ã£ set á»Ÿ trÃªn)\n    \n    // 2. doc_id\n    metadata.doc_id = parseYamlValue(/doc_id:\\s*\"([^\"]+)\"/);\n    \n    // 3. doc_type\n    metadata.doc_type = parseYamlValue(/doc_type:\\s*\"([^\"]+)\"/);\n    \n    // 4. hotel_id (fallback to parent_hotel_id)\n    metadata.hotel_id = parseYamlValue(/hotel_id:\\s*\"([^\"]+)\"/) || \n                        parseYamlValue(/parent_hotel_id:\\s*\"([^\"]+)\"/);\n    \n    // 5. hotel_name (fallback logic tá»« content body náº¿u null)\n    metadata.hotel_name = parseYamlValue(/location:\\s*[\\s\\S]*?hotel_name:\\s*\"([^\"]+)\"/) || \n                         parseYamlValue(/hotel_name:\\s*\"([^\"]+)\"/);\n    \n    // === 2. LOCATION ===\n    // 6. city_name (prefer city_name, fallback to city)\n    metadata.city_name = parseYamlValue(/city_name:\\s*\"([^\"]+)\"/) || \n                         parseYamlValue(/location:\\s*[\\s\\S]*?city_name:\\s*\"([^\"]+)\"/) ||\n                         parseYamlValue(/location:\\s*[\\s\\S]*?city:\\s*\"([^\"]+)\"/) || \n                         parseYamlValue(/city:\\s*\"([^\"]+)\"/);\n    \n    // 7. district_name (prefer district_name, fallback to district)\n    metadata.district_name = parseYamlValue(/district_name:\\s*\"([^\"]+)\"/) || \n                              parseYamlValue(/location:\\s*[\\s\\S]*?district_name:\\s*\"([^\"]+)\"/) ||\n                              parseYamlValue(/location:\\s*[\\s\\S]*?district:\\s*\"([^\"]+)\"/) || \n                              parseYamlValue(/district:\\s*\"([^\"]+)\"/);\n    \n    // 8. address (prefer full_address, fallback to address)\n    metadata.address = parseYamlValue(/full_address:\\s*\"([^\"]+)\"/) || \n                       parseYamlValue(/location:\\s*[\\s\\S]*?address:\\s*\"([^\"]+)\"/) || \n                       parseYamlValue(/address:\\s*\"([^\"]+)\"/);\n    \n    // === 3. STATS ===\n    // 9. star_rating (parse as int)\n    metadata.star_rating = parseYamlValue(/star_rating:\\s*(\\d+)/);\n    if (metadata.star_rating !== null) {\n      metadata.star_rating = parseInt(metadata.star_rating, 10);\n    }\n    \n    // 10. review_score (parse as float)\n    metadata.review_score = parseYamlValue(/review_score:\\s*([\\d.]+)/);\n    if (metadata.review_score !== null) {\n      metadata.review_score = parseFloat(metadata.review_score);\n    }\n    \n    // 11. review_count (parse as int)\n    metadata.review_count = parseYamlValue(/review_count:\\s*(\\d+)/);\n    if (metadata.review_count !== null) {\n      metadata.review_count = parseInt(metadata.review_count, 10);\n    }\n    \n    // === 4. PRICE & PROPS ===\n    // 12. price (base_price, fallback to reference_min_price, default 0)\n    const basePrice = parseYamlValue(/base_price:\\s*(\\d+)/);\n    const referenceMinPrice = parseYamlValue(/reference_min_price:\\s*(\\d+)/);\n    metadata.price = basePrice || referenceMinPrice || 0;\n    if (metadata.price !== null) {\n      metadata.price = parseInt(metadata.price, 10);\n    }\n    \n    // 13. amenities (combine amenity_tags AND room_amenity_tags into one array)\n    const amenityTags = parseYamlArraySimple('amenity_tags');\n    const roomAmenityTags = parseYamlArraySimple('room_amenity_tags');\n    metadata.amenities = [...(amenityTags || []), ...(roomAmenityTags || [])];\n    \n    // 14. breakfast_included (boolean)\n    metadata.breakfast_included = parseYamlValue(/breakfast_included:\\s*(true|false)/);\n    \n    // === 5. ROOM DETAILS ===\n    // 15. room_name\n    metadata.room_name = parseYamlValue(/room_name:\\s*\"([^\"]+)\"/);\n    \n    // 16. max_adults (parse as int)\n    metadata.max_adults = parseYamlValue(/max_adults:\\s*(\\d+)/);\n    if (metadata.max_adults !== null) {\n      metadata.max_adults = parseInt(metadata.max_adults, 10);\n    }\n    \n    // 17. max_children (parse as int)\n    metadata.max_children = parseYamlValue(/max_children:\\s*(\\d+)/);\n    if (metadata.max_children !== null) {\n      metadata.max_children = parseInt(metadata.max_children, 10);\n    }\n    \n    // 18. view_type (check view first, then view_type, including nested specs)\n    metadata.view_type = parseYamlValue(/view:\\s*\"([^\"]+)\"/);\n    if (!metadata.view_type) {\n      // Check nested specs.view_type first\n      const specsViewTypeMatch = yamlContent.match(/^specs:\\s*$/m);\n      if (specsViewTypeMatch) {\n        const specsStartIndex = specsViewTypeMatch.index + specsViewTypeMatch[0].length;\n        const specsSection = yamlContent.substring(specsStartIndex);\n        const nestedViewTypeMatch = specsSection.match(/^\\s+view_type:\\s*\"([^\"]+)\"/m);\n        if (nestedViewTypeMatch) {\n          metadata.view_type = nestedViewTypeMatch[1];\n        }\n      }\n      // Fallback to root level view_type if not found\n      if (!metadata.view_type) {\n        metadata.view_type = parseYamlValue(/view_type:\\s*\"([^\"]+)\"/);\n      }\n    }\n    \n    // 19. bed_type\n    metadata.bed_type = parseYamlValue(/bed_type:\\s*\"([^\"]+)\"/);\n    \n    // 20. area_sqm (parse as float)\n    metadata.area_sqm = parseYamlValue(/area_sqm:\\s*([\\d.]+)/);\n    if (metadata.area_sqm !== null) {\n      metadata.area_sqm = parseFloat(metadata.area_sqm);\n    }\n    \n    // === 6. ADDITIONAL IMPORTANT FIELDS ===\n    // 21. wifi_available (boolean)\n    metadata.wifi_available = parseYamlValue(/wifi_available:\\s*(true|false)/);\n    \n    // 22. smoking_allowed (boolean)\n    metadata.smoking_allowed = parseYamlValue(/smoking_allowed:\\s*(true|false)/);\n    \n    // 23. to_beach_meters (integer) - from distances.to_beach_meters\n    const distancesBeachMatch = yamlContent.match(/distances:\\s*[\\s\\S]*?to_beach_meters:\\s*(\\d+)/);\n    if (distancesBeachMatch) {\n      metadata.to_beach_meters = parseInt(distancesBeachMatch[1], 10);\n    } else {\n      metadata.to_beach_meters = parseYamlValue(/to_beach_meters:\\s*(\\d+)/);\n    }\n    \n    // 24. room_type (string)\n    metadata.room_type = parseYamlValue(/room_type:\\s*\"([^\"]+)\"/);\n    \n    // 25. has_balcony (boolean) - check nested specs.has_balcony first, then root level\n    const specsHasBalconyMatch = yamlContent.match(/^specs:\\s*$/m);\n    if (specsHasBalconyMatch) {\n      const specsStartIndex = specsHasBalconyMatch.index + specsHasBalconyMatch[0].length;\n      const specsSection = yamlContent.substring(specsStartIndex);\n      const nestedHasBalconyMatch = specsSection.match(/^\\s+has_balcony:\\s*(true|false)/m);\n      if (nestedHasBalconyMatch) {\n        metadata.has_balcony = nestedHasBalconyMatch[1] === 'true';\n      }\n    }\n    // Fallback to root level has_balcony if not found in specs\n    if (metadata.has_balcony === undefined) {\n      const hasBalconyValue = parseYamlValue(/has_balcony:\\s*(true|false)/);\n      if (hasBalconyValue !== null) {\n        metadata.has_balcony = hasBalconyValue;\n      }\n    }\n    \n    // Fallback: TrÃ­ch xuáº¥t hotel_name tá»« content body náº¿u chÆ°a cÃ³\n    if (!metadata.hotel_name && !metadata.room_name) {\n      const contentBody = rawContent.replace(/^---[\\s\\S]*?---\\s*/, '');\n      const titleMatch = contentBody.match(/^#\\s*(?:ğŸ¨|ğŸ›ï¸|.*?)\\s*(.+?)(?:\\s*-)?$/m);\n      if (titleMatch) {\n        metadata.hotel_name = titleMatch[1].trim();\n      }\n    }\n\n    // 3. Xá»¬ LÃ LÃ€M Sáº CH VÄ‚N Báº¢N (Tá»I Æ¯U)\n    let text = rawContent;\n    \n    // --- 3.1: Loáº¡i bá» khá»‘i rÃ¡c lá»›n (gá»™p regex Ä‘á»ƒ tá»‘i Æ°u) ---\n    text = text\n      .replace(/^---[\\s\\S]*?---\\s*/, '')           // XÃ³a YAML Frontmatter\n      .replace(/^# ===.*$/gm, '')                    // XÃ³a Header trang trÃ­\n      .replace(/\\{\\{TOOL:.*?\\}\\}/g, '')              // XÃ³a code Tool\n      .replace(/!\\[.*?\\]\\([^)]*\\)/g, '');           // XÃ³a áº£nh Markdown\n    \n    // --- 3.2: Decode HTML Entities (tá»‘i Æ°u: gá»™p cÃ¡c pattern tÆ°Æ¡ng tá»±) ---\n    text = text\n      .replace(/&#10;/g, '\\n')                       // Line feed\n      .replace(/&#13;/g, '\\n')                       // Carriage return -> newline\n      .replace(/&#9;/g, ' ')                         // Tab -> space\n      .replace(/&nbsp;|&#160;/g, ' ')                // Non-breaking space\n      .replace(/&amp;/g, '&')\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#39;|&apos;/g, \"'\")\n      .replace(/<[^>]*>/g, '');                      // XÃ³a tháº» HTML\n    \n    // Decode HTML entities dáº¡ng sá»‘ vÃ  hex (chá»‰ giá»¯ kÃ½ tá»± há»£p lá»‡)\n    text = text\n      .replace(/&#(\\d+);/g, (_, code) => {\n        const c = parseInt(code, 10);\n        return (c === 10 || c === 13 || (c >= 32 && c <= 126) || c >= 160) \n          ? (c === 13 ? '\\n' : String.fromCharCode(c)) : '';\n      })\n      .replace(/&#x([0-9A-Fa-f]+);/g, (_, hex) => {\n        const c = parseInt(hex, 16);\n        return (c === 10 || c === 13 || (c >= 32 && c <= 126) || c >= 160) \n          ? (c === 13 ? '\\n' : String.fromCharCode(c)) : '';\n      });\n    \n    // --- 3.3: XÃ³a Ä‘á»‹nh dáº¡ng Markdown (giá»¯ text) - tá»‘i Æ°u regex ---\n    text = text\n      .replace(/^#+\\s+/gm, '')                      // XÃ³a dáº¥u # Header\n      .replace(/\\*\\*([^*]+)\\*\\*/g, '$1')             // XÃ³a Bold **\n      .replace(/\\*([^*]+)\\*/g, '$1')                 // XÃ³a Italic *\n      .replace(/__([^_]+)__/g, '$1')                 // XÃ³a Bold __\n      .replace(/^>\\s*/gm, '')                        // XÃ³a Blockquote >\n      .replace(/^\\s*[-*+]\\s+/gm, '')                 // XÃ³a dáº¥u gáº¡ch Ä‘áº§u dÃ²ng list\n      .replace(/`([^`]+)`/g, '$1');                  // XÃ³a inline code\n    \n    // --- 3.3.5: Loáº¡i bá» cÃ¡c báº£ng trÃ¹ng láº·p (DUPLICATE TABLE REMOVAL) ---\n    // PhÃ¡t hiá»‡n vÃ  xÃ³a cÃ¡c báº£ng bá»‹ duplicate, Ä‘áº·c biá»‡t lÃ  báº£ng \"ğŸ“† ThÃ´ng Tin Theo NgÃ y\"\n    // Strategy: PhÃ¡t hiá»‡n cáº£ header emoji VÃ€ dÃ²ng header báº£ng (sau khi xÃ³a markdown)\n    // LÆ¯U Ã: Header Ä‘Ã£ bá»‹ xÃ³a markdown (#) á»Ÿ bÆ°á»›c 3.3, nÃªn chá»‰ cÃ²n text thuáº§n\n    \n    const tableLines = text.split('\\n');\n    const dedupedLines = [];\n    const seenTableHeaders = new Set();\n    const seenTableRowHeaders = new Set(); // DÃ²ng header cá»§a báº£ng (khÃ´ng cÃ³ emoji)\n    let skipUntilNextHeader = false;\n    let inTableSection = false;\n    \n    for (let i = 0; i < tableLines.length; i++) {\n      const line = tableLines[i];\n      const trimmed = line.trim();\n      \n      // PhÃ¡t hiá»‡n header cá»§a báº£ng cÃ³ emoji (SAU KHI ÄÃƒ XÃ“A MARKDOWN)\n      const isTableHeaderEmoji = /^ğŸ“†\\s*ThÃ´ng Tin Theo NgÃ y/.test(trimmed) ||\n                                 /^ğŸ’°\\s*GiÃ¡\\s*&\\s*TÃ¬nh Tráº¡ng Trong 7 NgÃ y Tá»›i/.test(trimmed);\n      \n      // PhÃ¡t hiá»‡n dÃ²ng header cá»§a báº£ng (khÃ´ng cÃ³ emoji) - pattern phá»• biáº¿n\n      const isTableRowHeader = /^NgÃ y\\s+Thá»©\\s+GiÃ¡\\s*\\(VNÄ/.test(trimmed) ||\n                               /^NgÃ y\\s+Thá»©\\s+GiÃ¡\\s*\\(VNÄ\\/Ä‘Ãªm\\)/.test(trimmed) ||\n                               (/^NgÃ y/.test(trimmed) && /Thá»©/.test(trimmed) && /GiÃ¡/.test(trimmed));\n      \n      // PhÃ¡t hiá»‡n dÃ²ng báº£ng (cÃ³ chá»©a |) - QUAN TRá»ŒNG: pháº£i check TRÆ¯á»šC khi flatten\n      const isTableRow = /\\|/.test(line);\n      \n      // PhÃ¡t hiá»‡n dÃ²ng dá»¯ liá»‡u báº£ng (cÃ³ pattern ngÃ y thÃ¡ng: 2025-11-29, 2025-12-01, etc.)\n      const isTableDataRow = /^\\d{4}-\\d{2}-\\d{2}/.test(trimmed) && \n                            (/\\bsaturday\\b|\\bsunday\\b|\\bmonday\\b|\\btuesday\\b|\\bwednesday\\b|\\bthursday\\b|\\bfriday\\b/i.test(trimmed) ||\n                             /\\d+\\.\\d+\\s+\\d+/.test(trimmed)); // Pattern: giÃ¡ sá»‘ + sá»‘ phÃ²ng\n      \n      // PhÃ¡t hiá»‡n header má»›i (khÃ´ng pháº£i báº£ng duplicate) - cÃ¡c emoji khÃ¡c\n      const isNewHeader = /^[ğŸ¯â­ğŸğŸ“‹ğŸ“ğŸ›ï¸â°âœ¨ğŸ‘¨|ğŸ–ï¸âŒğŸ”„ğŸ’³ğŸ“ğŸ“ŠğŸ“ˆğŸ“…ğŸš­âš ï¸]/.test(trimmed) && \n                        !isTableHeaderEmoji;\n      \n      if (isTableHeaderEmoji) {\n        // Header cÃ³ emoji\n        const tableKey = trimmed.replace(/\\s+/g, ' ').trim();\n        \n        if (seenTableHeaders.has(tableKey)) {\n          skipUntilNextHeader = true;\n          inTableSection = true;\n        } else {\n          seenTableHeaders.add(tableKey);\n          skipUntilNextHeader = false;\n          inTableSection = true;\n          dedupedLines.push(line);\n        }\n      } else if (isTableRowHeader) {\n        // DÃ²ng header cá»§a báº£ng (khÃ´ng cÃ³ emoji) - Ä‘Ã¢y lÃ  dáº¥u hiá»‡u báº¯t Ä‘áº§u báº£ng má»›i\n        const rowHeaderKey = trimmed.replace(/\\s+/g, ' ').trim();\n        \n        if (seenTableRowHeaders.has(rowHeaderKey)) {\n          // ÄÃ£ tháº¥y dÃ²ng header nÃ y rá»“i = báº£ng duplicate\n          skipUntilNextHeader = true;\n          inTableSection = true;\n        } else {\n          // DÃ²ng header má»›i\n          seenTableRowHeaders.add(rowHeaderKey);\n          skipUntilNextHeader = false;\n          inTableSection = true;\n          dedupedLines.push(line);\n        }\n      } else if (skipUntilNextHeader && inTableSection) {\n        // Äang trong báº£ng duplicate, bá» qua táº¥t cáº£ dÃ²ng cho Ä‘áº¿n khi gáº·p header má»›i hoáº·c ná»™i dung khÃ´ng pháº£i báº£ng\n        if (isNewHeader) {\n          // Gáº·p header má»›i (emoji khÃ¡c), dá»«ng skip\n          skipUntilNextHeader = false;\n          inTableSection = false;\n          dedupedLines.push(line);\n        } else if (isTableRowHeader) {\n          // Gáº·p dÃ²ng header báº£ng má»›i (duplicate tiáº¿p theo) - tiáº¿p tá»¥c skip, khÃ´ng push\n          // KhÃ´ng lÃ m gÃ¬, tiáº¿p tá»¥c skip\n        } else if (!isTableDataRow && trimmed.length > 0 && !/^[\\s-:|]+$/.test(trimmed)) {\n          // Gáº·p ná»™i dung khÃ´ng pháº£i dá»¯ liá»‡u báº£ng (cÃ³ text thá»±c sá»±, khÃ´ng pháº£i separator)\n          // Kiá»ƒm tra xem dÃ²ng trÆ°á»›c Ä‘Ã³ cÃ³ pháº£i lÃ  dá»¯ liá»‡u báº£ng khÃ´ng\n          let prevIsTableData = false;\n          for (let j = i - 1; j >= 0 && j >= i - 5; j--) {\n            const prevLine = tableLines[j] || '';\n            const prevTrimmed = prevLine.trim();\n            if (prevTrimmed.length > 0) {\n              prevIsTableData = /^\\d{4}-\\d{2}-\\d{2}/.test(prevTrimmed);\n              break;\n            }\n          }\n          \n          if (prevIsTableData) {\n            // DÃ²ng trÆ°á»›c Ä‘Ã³ lÃ  dá»¯ liá»‡u báº£ng, Ä‘Ã¢y lÃ  káº¿t thÃºc báº£ng duplicate\n            skipUntilNextHeader = false;\n            inTableSection = false;\n            dedupedLines.push(line);\n          }\n        }\n        // Táº¥t cáº£ cÃ¡c dÃ²ng khÃ¡c (dá»¯ liá»‡u báº£ng, dÃ²ng trá»‘ng) Ä‘á»u bá»‹ skip - khÃ´ng push vÃ o dedupedLines\n      } else {\n        // KhÃ´ng trong báº£ng duplicate, giá»¯ nguyÃªn\n        if (inTableSection && !isTableRow && !isTableDataRow && trimmed.length > 0) {\n          // Káº¿t thÃºc section báº£ng náº¿u gáº·p ná»™i dung khÃ´ng pháº£i báº£ng\n          inTableSection = false;\n        }\n        dedupedLines.push(line);\n      }\n    }\n    \n    text = dedupedLines.join('\\n');\n    \n    // --- 3.4: Xá»­ lÃ½ Báº£ng (Table Flattening) - tá»‘i Æ°u ---\n    text = text\n      .replace(/^\\|?[\\s-:|]+\\|?$/gm, '')             // XÃ³a dÃ²ng káº» báº£ng\n      .replace(/\\|/g, ' ');                           // Thay dáº¥u | báº±ng space\n    \n    // --- 3.5: XÃ³a text rÃ¡c cá»¥ thá»ƒ ---\n    text = text\n      .replace(/_ThÃ´ng tin.*?cáº­p nháº­t sá»›m\\._/g, '')\n      .replace(/_Hiá»‡n táº¡i khÃ´ng cÃ³.*?_/g, '')\n      .replace(/Disclaimer quan trá»ng/g, '')\n      .replace(/\\{\\{.*?\\}\\}/g, '');                  // XÃ³a táº¥t cáº£ template variables cÃ²n sÃ³t\n    \n    // --- 3.6: Dá»n dáº¹p cuá»‘i cÃ¹ng (tá»‘i Æ°u thá»© tá»±) ---\n    text = text\n      .replace(/\\r\\n|\\r/g, '\\n')                     // Chuáº©n hÃ³a line endings (quan trá»ng!)\n      .replace(/[\\u200B-\\u200D\\u2060\\uFEFF]/g, '')   // Loáº¡i bá» zero-width characters\n      .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F]/g, '') // Loáº¡i bá» control chars\n      .replace(/[\\u2028\\u2029]/g, '\\n')              // Chuáº©n hÃ³a line separators\n      .replace(/[\\u2000-\\u200A\\u202F\\u205F\\u00A0]/g, ' ') // Chuáº©n hÃ³a space\n      .replace(/[ \\t]+/g, ' ')                       // XÃ³a khoáº£ng tráº¯ng thá»«a (quan trá»ng!)\n      .replace(/\\n\\s*\\n\\s*\\n+/g, '\\n\\n')            // Tá»‘i Ä‘a 2 dÃ²ng trá»‘ng\n      .replace(/[ \\t]+$/gm, '')                      // XÃ³a trailing whitespace\n      .replace(/[\\uFFFD\\u00AD\\0]/g, '')              // Loáº¡i bá» replacement char, soft hyphen, null\n      .trim();\n    \n    // --- 3.7: SEMANTIC CLEANING - Tá»‘i Æ°u cho Vector DB ---\n    \n    // 3.7.1: Sá»­a artifacts cÃ²n sÃ³t\n    text = text\n      .replace(/:\\s*\\}\\s*$/gm, '')                   // XÃ³a dáº¥u } cÃ²n sÃ³t á»Ÿ cuá»‘i dÃ²ng\n      .replace(/âš ï¸\\s*:\\s*$/gm, 'âš ï¸ Disclaimer quan trá»ng:') // Sá»­a tiÃªu Ä‘á» bá»‹ máº¥t\n      .replace(/âš ï¸\\s*:\\s*\\n/g, 'âš ï¸ Disclaimer quan trá»ng:\\n'); // Sá»­a tiÃªu Ä‘á» bá»‹ máº¥t (trÆ°á»ng há»£p khÃ¡c)\n    \n    // 3.7.2: Loáº¡i bá» conversational fluff (ká»‹ch báº£n chatbot)\n    text = text\n      .replace(/ğŸ“\\s*LiÃªn Há»‡\\s*&\\s*Há»— Trá»£[\\s\\S]*?HÃ£y cho tÃ´i biáº¿t káº¿ hoáº¡ch cá»§a báº¡n![\\s\\S]*$/g, '') // XÃ³a toÃ n bá»™ pháº§n liÃªn há»‡\n      .replace(/Báº¡n cÃ³ cÃ¢u há»i vá» khÃ¡ch sáº¡n nÃ y\\?[\\s\\S]*?ğŸ˜Š[\\s\\S]*$/g, '') // XÃ³a pháº§n há»— trá»£\n      .replace(/TÃ´i cÃ³ thá»ƒ giÃºp báº¡n:[\\s\\S]*?ğŸ˜Š[\\s\\S]*$/g, '') // XÃ³a danh sÃ¡ch há»— trá»£\n      .replace(/HÃ£y cho tÃ´i biáº¿t[\\s\\S]*?ğŸ˜Š[\\s\\S]*$/g, '') // XÃ³a cÃ¢u káº¿t thÃºc\n      .replace(/TÃ´i sáº½ kiá»ƒm tra ngay:[\\s\\S]*$/gm, '') // XÃ³a cÃ¢u tool call\n      .replace(/ğŸ”\\s*Äá»ƒ nháº­n bÃ¡o giÃ¡ chÃ­nh xÃ¡c cho ngÃ y báº¡n muá»‘n Ä‘i, hÃ£y cho tÃ´i biáº¿t:[\\s\\S]*?TÃ´i sáº½ kiá»ƒm tra ngay\\s*$/gm, ''); // XÃ³a Ä‘oáº¡n disclaimer thá»«a\n    \n    // 3.7.3: Loáº¡i bá» sections rá»—ng (tiÃªu Ä‘á» khÃ´ng cÃ³ ná»™i dung)\n    // XÃ³a cÃ¡c section rá»—ng cá»¥ thá»ƒ (pattern cá»¥ thá»ƒ - xá»­ lÃ½ cáº£ trÆ°á»ng há»£p khÃ´ng cÃ³ dÃ²ng trá»‘ng)\n    text = text\n      .replace(/âœ¨\\s*Tiá»‡n Nghi Ná»•i Báº­t\\s*\\n(?:\\s*\\n)?(?=[ğŸ‘¨ğŸ›ï¸ğŸ’°ğŸ“‹ğŸ“â°â­ğŸ¯âŒğŸ”„ğŸ’³])/g, '') // Section rá»—ng - nháº£y ngay sang header khÃ¡c\n      .replace(/â­\\s*ÄÃ¡nh GiÃ¡ KhÃ¡ch HÃ ng\\s*\\n(?:\\s*\\n)?(?=[ğŸ“‹ğŸ“â°ğŸ¯âŒğŸ”„ğŸ’³])/g, '') // Section rá»—ng\n      .replace(/âŒ\\s*ChÃ­nh SÃ¡ch Há»§y PhÃ²ng Chi Tiáº¿t\\s*\\n(?:\\s*\\n)?(?=[ğŸ”„ğŸ’³ğŸ“‹ğŸ“â°ğŸ¯])/g, '') // Section rá»—ng\n      .replace(/ğŸ”„\\s*ChÃ­nh SÃ¡ch Äá»•i Lá»‹ch Chi Tiáº¿t\\s*\\n(?:\\s*\\n)?(?=[ğŸ’³ğŸ“‹ğŸ“â°ğŸ¯])/g, '') // Section rá»—ng\n      .replace(/ğŸ¯\\s*PhÃ¹ Há»£p Vá»›i Ai\\?\\s*$/gm, '') // Section rá»—ng á»Ÿ cuá»‘i file\n      .replace(/ğŸ¯\\s*Äá»‹a Äiá»ƒm Giáº£i TrÃ­ Gáº§n ÄÃ¢y\\s*\\n(?:\\s*\\n)?(?=[â­ğŸ“‹ğŸ“â°ğŸ¯âŒğŸ”„ğŸ’³])/g, '') // Section rá»—ng\n      .replace(/ğŸ\\s*Khuyáº¿n MÃ£i Äang CÃ³\\s*\\n(?:\\s*\\n)?(?=[â­ğŸ“‹ğŸ“â°ğŸ¯âŒğŸ”„ğŸ’³])/g, ''); // Section rá»—ng\n    \n    // XÃ³a pattern: Header + chá»‰ cÃ³ dÃ²ng trá»‘ng + Header má»›i (generic - cáº£i thiá»‡n)\n    const lines = text.split('\\n');\n    const cleanedLines = [];\n    const headerPattern = /^[ğŸ¯â­ğŸğŸ“‹ğŸ“ğŸ›ï¸ğŸ’°â°âœ¨ğŸ‘¨|ğŸ–ï¸âŒğŸ”„ğŸ’³ğŸ“]/;\n    \n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n      const isHeader = headerPattern.test(line);\n      \n      if (isHeader) {\n        // Kiá»ƒm tra xem cÃ³ ná»™i dung sau header khÃ´ng\n        let hasContent = false;\n        let nextHeaderIndex = -1;\n        \n        // TÃ¬m header tiáº¿p theo hoáº·c ná»™i dung thá»±c sá»±\n        for (let j = i + 1; j < lines.length && j < i + 6; j++) {\n          const nextLine = lines[j].trim();\n          \n          // Náº¿u gáº·p header má»›i\n          if (headerPattern.test(nextLine)) {\n            nextHeaderIndex = j;\n            break;\n          }\n          \n          // Náº¿u cÃ³ ná»™i dung thá»±c sá»± (khÃ´ng pháº£i dÃ²ng trá»‘ng, khÃ´ng pháº£i chá»‰ cÃ³ dáº¥u cÃ¢u)\n          if (nextLine.length > 2 && !/^[:\\-_\\s]+$/.test(nextLine)) {\n            hasContent = true;\n            break;\n          }\n        }\n        \n        // Quyáº¿t Ä‘á»‹nh: giá»¯ header náº¿u cÃ³ ná»™i dung, xÃ³a náº¿u header ngay trÆ°á»›c header khÃ¡c\n        if (hasContent) {\n          cleanedLines.push(lines[i]);\n        } else if (nextHeaderIndex === i + 1) {\n          // Header ngay trÆ°á»›c header khÃ¡c (khÃ´ng cÃ³ dÃ²ng trá»‘ng) = section rá»—ng, bá» qua\n        } else if (nextHeaderIndex > 0 && nextHeaderIndex < i + 4) {\n          // Header trÆ°á»›c header khÃ¡c sau 1-3 dÃ²ng trá»‘ng = section rá»—ng, bá» qua\n        } else if (i === lines.length - 1) {\n          // Header á»Ÿ cuá»‘i file mÃ  khÃ´ng cÃ³ ná»™i dung = xÃ³a\n        } else {\n          // TrÆ°á»ng há»£p khÃ¡c, giá»¯ láº¡i Ä‘á»ƒ an toÃ n\n          cleanedLines.push(lines[i]);\n        }\n      } else {\n        cleanedLines.push(lines[i]);\n      }\n    }\n    \n    text = cleanedLines.join('\\n');\n    \n    // 3.7.4: Dá»n dáº¹p láº¡i sau khi xÃ³a sections\n    text = text\n      .replace(/\\n{3,}/g, '\\n\\n')                     // Tá»‘i Ä‘a 2 dÃ²ng trá»‘ng\n      .replace(/^\\s+|\\s+$/gm, '')                     // XÃ³a leading/trailing whitespace má»—i dÃ²ng\n      .trim();\n\n    // 4. GHI Dá»® LIá»†U RA\n    item.json.cleanedContent = text;\n    item.json.metadata = metadata;\n    item.binary = undefined;\n  }\n}\n\nreturn $input.all();\n\n/*\n * ============================================================\n * HÆ¯á»šNG DáºªN Sá»¬ Dá»¤NG METADATA Vá»šI PINECONE VECTOR DB\n * ============================================================\n * \n * Metadata Ä‘Ã£ Ä‘Æ°á»£c trÃ­ch xuáº¥t tá»« YAML Frontmatter vÃ  sáºµn sÃ ng cho Pinecone filtering.\n * \n * Cáº¤U HÃŒNH DATA LOADER (Pinecone):\n * \n * 1. Metadata Fields cho Filtering:\n *    - doc_type: \"hotel_profile\" | \"room_detail\"\n *    - doc_id, hotel_id, room_id: UUID strings\n *    - location: country, city, district (strings)\n *    - star_rating: integer (1-5)\n *    - reference_min_price, base_price: integer (VNÄ)\n *    - amenity_tags, location_tags, vibe_tags: arrays of strings\n *    - distances: to_beach_meters, to_city_center_meters (integers)\n *    - policies: breakfast_included, smoking_allowed (booleans)\n * \n * 2. VÃ­ dá»¥ Query vá»›i Metadata Filtering:\n * \n *    // TÃ¬m khÃ¡ch sáº¡n cÃ³ bá»ƒ bÆ¡i táº¡i Nha Trang\n *    filter = {\n *      doc_type: \"hotel_profile\",\n *      city: \"thanh-pho-nha-trang\",\n *      amenity_tags: { $in: [\"swimming_pool\", \"pool\"] }\n *    }\n * \n *    // TÃ¬m phÃ²ng giÃ¡ dÆ°á»›i 1 triá»‡u táº¡i Golden Hotel\n *    filter = {\n *      doc_type: \"room_detail\",\n *      parent_hotel_id: \"4b2d0a2d-cc1f-4030-8c07-5fa09b8229cf\",\n *      base_price: { $lt: 1000000 }\n *    }\n * \n *    // TÃ¬m khÃ¡ch sáº¡n 4-5 sao gáº§n biá»ƒn (< 500m)\n *    filter = {\n *      doc_type: \"hotel_profile\",\n *      star_rating: { $gte: 4 },\n *      to_beach_meters: { $lt: 500 }\n *    }\n * \n * 3. Cáº¥u trÃºc Metadata trong Pinecone:\n *    {\n *      id: metadata.doc_id,\n *      values: [vector embeddings],\n *      metadata: {\n *        doc_type: metadata.doc_type,\n *        hotel_id: metadata.hotel_id,\n *        city: metadata.city,\n *        star_rating: metadata.star_rating,\n *        reference_min_price: metadata.reference_min_price,\n *        amenity_tags: metadata.amenity_tags,  // Array\n *        // ... cÃ¡c trÆ°á»ng khÃ¡c\n *      }\n *    }\n * \n * 4. LÆ°u Ã½:\n *    - Arrays (amenity_tags, location_tags) cáº§n Ä‘Æ°á»£c filter báº±ng $in operator\n *    - Numbers (price, distance) dÃ¹ng $lt, $lte, $gt, $gte\n *    - Booleans dÃ¹ng exact match\n *    - Strings dÃ¹ng exact match hoáº·c $in cho multiple values\n */\n\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          400,
          0
        ],
        "id": "5606c41d-1eb4-4b94-a515-c6af95f43f22",
        "name": "Convert Markdown files to Text files"
      }
    ],
    "connections": {
      "Embeddings OpenAI": {
        "ai_embedding": [
          [
            {
              "node": "Pinecone Vector Store",
              "type": "ai_embedding",
              "index": 0
            }
          ]
        ]
      },
      "Get KB data from S3": {
        "main": [
          [
            {
              "node": "Convert from XML to JSON",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Convert from XML to JSON": {
        "main": [
          [
            {
              "node": "Split",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Split": {
        "main": [
          [
            {
              "node": "Download files from S3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download files from S3": {
        "main": [
          [
            {
              "node": "Convert Markdown files to Text files",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "When clicking â€˜Execute workflowâ€™": {
        "main": [
          [
            {
              "node": "Get KB data from S3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Default Data Loader": {
        "ai_document": [
          [
            {
              "node": "Pinecone Vector Store",
              "type": "ai_document",
              "index": 0
            }
          ]
        ]
      },
      "Recursive Character Text Splitter": {
        "ai_textSplitter": [
          [
            {
              "node": "Default Data Loader",
              "type": "ai_textSplitter",
              "index": 0
            }
          ]
        ]
      },
      "Convert Markdown files to Text files": {
        "main": [
          [
            {
              "node": "Pinecone Vector Store",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "pinData": {},
    "meta": {
      "templateCredsSetupCompleted": true,
      "instanceId": "c57b70723f54864769ece4aeb1aa72368bc75704a74d49344e0597a9701afb0d"
    }
  }